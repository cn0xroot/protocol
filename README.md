# NFCGate Protocol
This repository contains the source files that are used in the [server](https://github.com/nfcgate/server), [MitM-Proxy](https://github.com/nfcgate/mitm), and [main application](https://github.com/nfcgate/nfcgate). They have to be compiled using [Google Protocol Buffers](https://github.com/google/protobuf/), version 2.6.1 (NOT 3.X). The compiled files are already shipped within the respective repositories, so you only need to touch these files if you want to modify the protocol.

# Protocol Specifications
The protocol offers a few different functions, each with their own protocol messages. In this document, we'll try to give an overview of how the protocol works. Again, you only need to know this if you want to change it or implement your own clients. The message types are split into three different protobuf files:
- c2s.proto contains messages passed between client and server. This is mostly related to session management and message passing
- c2c.proto contains messages passed between two clients. This includes the meat of the protocol: Passing NFC data and status information
- metaMessage.proto contains only one data type: A Wrapper message that is used to identify the type of message that is passed

## Wrapper Messages
Wrapper messages are only required because we can only parse the transferred bytes into Protobuf messages if we know the type of message to parse it into. For this purpose, we introduced a wrapper message, which contains exactly one message any other message type. That way, we can parse any incoming message as a wrapper message and then use the functions the parsed message offers to identify which type of message is contained in it.

**Developers:** If you want to send any message, you MUST wrap it in a wrapper message. If you want to add new message types, you need to add them to this message type as well (and obviously add support for it in all clients that need to understand it).

## Session Management
Clients connect using sessions. Each session can have one or two participants (although a session with one participant is not very useful and generally only happens while you wait for the second device to connect). Sessions are identified using a 6-digit session token, which is generated by the server.

A session is started by a client sending a Session Message (defined in c2s.proto) with an opcode of SESSION_CREATE and a SessionErrorCode of ERROR_NOERROR (this should be the default value anyway). As mentioned before, the session message MUST be wrapped in a Wrapper message. It can then be serialized into a byte[] and sent over the wire to the server. The server will parse the Wrapper message, see that it contains a Session message, parse that message, see that it is a session creation request, and then perform the following algorithm (as pseudocode, if errcode is not set, it defaults to ERROR_NOERROR. Replies are always wrapped in a Wrapper message):

    if (client already in session):
        reply (opcode=SESSION_CREATE_FAIL, errcode=ERROR_CREATE_ALREADY_HAS_SESSION)
    else:
        generate random unique 6-digit token
        create session identified by that token
        add client to that session
        reply (opcode=SESSION_CREATE_SUCCESS, session_secret=token)

Clients can join a session by sending a Session message with an opcode of SESSION_JOIN, errcode ERROR_NOERROR, and session_secret set to the session token. The message is wrapped in a Wrapper message and passed to the server. The server then performs the following algorithm (pseudocode, if errcode is not defined, it is set to ERROR_NOERROR, replies are always wrapped in a wrapper message):

    if (token not in database):
        reply (opcode=SESSION_JOIN_FAIL, errcode=ERROR_JOIN_UNKNOWN_SECRET)
    else if (session already has two participants):
        reply (opcode=SESSION_JOIN_FAIL, errcode=ERROR_JOIN_SESSION_FULL)
    else if (client is already in a session):
        reply (opcode=SESSION_JOIN_FAIL, errcode=ERROR_JOIN_ALREADY_HAS_SESSION)
    else:
        Add client to session
        reply (opcode=SESSION_JOIN_SUCCESS)
        notify other client that client has joined session (opcode=SESSION_PEER_JOINED)

Clients can also leave a session by sending a session message with opcode SESSION_LEAVE and session_secret set to the session token. The server will perform the following algorithm:

    if (client not in session identified by session_secret):
        reply (opcode=SESSION_LEAVE_FAIL, errcode=ERROR_LEAVE_NOT_JOINED)
    else if (no session with that token exists):
        reply (opcode=SESSION_LEAVE_FAIL, errcode=ERROR_LEAVE_NOT_JOINED)
    else:
        remove client from session
        reply (opcode=SESSION_LEAVE_SUCCESS)
        if (session empty):
            remove session from database
        else:
            notify other client (opcode=SESSION_PEER_LEFT)

This concludes the session management part of the protocol.

## Message passing between clients
TODO